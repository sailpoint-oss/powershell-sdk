#
# IdentityNow V3 API
# Use these APIs to interact with the IdentityNow platform to achieve repeatable, automated processes with greater scalability. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
# Version: 3.0.0
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

Get the configuration object 'Configuration'.

.DESCRIPTION

Get the configuration object 'Configuration'.

.OUTPUTS

System.Collections.Hashtable
#>
function Get-DefaultConfiguration {

    if($null -eq $Script:Configuration) {
        $Script:Configuration = [System.Collections.Hashtable]::new()
    }

    $Script:Configuration = Get-Config
    $Configuration = $Script:Configuration

    # persistent config values
    if (!($Configuration.BaseUrl[-1] -eq "/")) {
        $Configuration["BaseUrl"] = $Configuration.BaseUrl + "/"
    }

    $Configuration["TokenUrl"] = $Configuration.BaseUrl + "oauth/token"

    if (!$Configuration.containsKey("Token")) {
        $Configuration["Token"] = ""
    }

    if (!$Configuration.containsKey("TokenExpiration")) {
        $Configuration["TokenExpiration"] = ""
    }

    if (!$Configuration.containsKey("SkipCertificateCheck")) {
        $Configuration["SkipCertificateCheck"] = $false
    }
    
    if (!$Configuration["DefaultHeaders"]) {
        $Configuration["DefaultHeaders"] = @{}
    }

    if (!$Configuration.containsKey("MaximumRetryCount")) {
        $Configuration["MaximumRetryCount"] = 10
    }

    if (!$Configuration.containsKey("RetryIntervalSeconds")) {
        $Configuration["RetryIntervalSeconds"] = 5
    }

    if (!$Configuration.containsKey("Proxy")) {
        $Configuration["Proxy"] = $null
    }

    if (!$Configuration.containsKey("Experimental")) {
        $Configuration["Experimental"] = $false
    }

    if (!$Configuration.containsKey("ClientIdOverride")) {
        $Configuration["ClientIdOverride"] = $null
    }

    if (!$Configuration.containsKey("ClientSecretOverride")) {
        $Configuration["ClientSecretOverride"] = $null
    }

    Return $Configuration

}

<#
.SYNOPSIS

Set the configuration.

.DESCRIPTION

Set the configuration.

.PARAMETER BaseUrl
Base URL of the HTTP endpoints

.PARAMETER Username
Username in HTTP basic authentication

.PARAMETER Password
Password in HTTP basic authentication

.PARAMETER ApiKey
API Keys for authentication/authorization

.PARAMETER ApiKeyPrefix
Prefix in the API Keys

.PARAMETER Cookie
Cookie for authentication/authorization

.PARAMETER AccessToken
Access token for authentication/authorization

.PARAMETER SkipCertificateCheck
Skip certificate verification

.PARAMETER DefaultHeaders
Default HTTP headers to be included in the HTTP request

.PARAMETER Proxy
Proxy setting in the HTTP request, e.g.

$proxy = [System.Net.WebRequest]::GetSystemWebProxy()
$proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials

.PARAMETER PassThru
Return an object of the Configuration

.OUTPUTS

System.Collections.Hashtable
#>
function Set-DefaultConfiguration {

    [CmdletBinding()]
    Param(
        [string]$BaseUrl,
        [string]$Token,
        [AllowNull()]
        [Nullable[DateTime]]$TokenExpiration,
        [string]$TokenUrl,
        [string]$ClientId,
        [string]$ClientSecret,
        [string]$ClientIdOverride,
        [string]$ClientSecretOverride,
        [System.Nullable[Int32]]$MaximumRetryCount,
        [System.Nullable[Int32]]$RetryIntervalSeconds,
        [System.Nullable[Boolean]]$Experimental,
        [System.Object]$Proxy,
        [switch]$PassThru
    )

    Process {

        if($null -eq $Script:Configuration) {
            $Script:Configuration = [System.Collections.Hashtable]::new()
        }

        If ($BaseUrl) {
            # validate URL
            $URL = $BaseUrl -as [System.URI]
            if (!($null -ne $URL.AbsoluteURI -and $URL.Scheme -match '[http|https]')) {
                throw "Invalid URL '$($BaseUrl)' cannot be used in the base URL."
            }
            $Script:Configuration["BaseUrl"] = $BaseUrl
        }

        If ($Token) {
            $Script:Configuration['Token'] = $Token
        }

        If ($TokenExpiration) {
            $Script:Configuration['TokenExpiration'] = $TokenExpiration
        }

        If ($TokenUrl) {
            $Script:Configuration['TokenUrl'] = $TokenUrl
        }

        If ($ClientId) {
            $Script:Configuration['ClientId'] = $ClientId
        }

        If ($ClientSecret) {
            $Script:Configuration['ClientSecret'] = $ClientSecret
        }

        If ($ClientIdOverride) {
            $Script:Configuration['ClientIdOverride'] = $ClientIdOverride
        }

        If ($ClientSecretOverride) {
            $Script:Configuration['ClientSecretOverride'] = $ClientSecretOverride
        }

        If ($RetryIntervalSeconds) {
            $Script:Configuration['RetryIntervalSeconds'] = $RetryIntervalSeconds
        }

        If ($MaximumRetryCount) {
            $Script:Configuration['MaximumRetryCount'] = $MaximumRetryCount
        }

        If ($Experimental) {
            $Script:Configuration['Experimental'] = $Experimental
        }

        If ($null -ne $Proxy) {
            If ($Proxy.GetType().FullName -ne "System.Net.SystemWebProxy" -and $Proxy.GetType().FullName -ne "System.Net.WebProxy" -and $Proxy.GetType().FullName -ne "System.Net.WebRequest+WebProxyWrapperOpaque") {
                throw "Incorrect Proxy type '$($Proxy.GetType().FullName)'. Must be System.Net.WebProxy or System.Net.SystemWebProxy or System.Net.WebRequest+WebProxyWrapperOpaque."
            }
            $Script:Configuration['Proxy'] = $Proxy
        } else {
            $Script:Configuration['Proxy'] = $null
        }

        If ($PassThru.IsPresent) {
            $Script:Configuration
        }
    }
}

function Get-IDNAccessToken {
    [CmdletBinding()]
    Param(
        [string]$ClientId,
        [string]$ClientSecret
    )

    Write-Debug "Getting Access Token"

    # Priority: 1. Function parameters, 2. Override configuration, 3. Default configuration
    $effectiveClientId = if ($ClientId) { 
        $ClientId 
    } elseif ($Script:Configuration["ClientIdOverride"]) {
        $Script:Configuration["ClientIdOverride"]
    } else { 
        $Script:Configuration["ClientId"] 
    }
    
    $effectiveClientSecret = if ($ClientSecret) { 
        $ClientSecret 
    } elseif ($Script:Configuration["ClientSecretOverride"]) {
        $Script:Configuration["ClientSecretOverride"]
    } else { 
        $Script:Configuration["ClientSecret"] 
    }

    if ($null -eq $effectiveClientId -or $null -eq $effectiveClientSecret -or $null -eq $Script:Configuration["TokenUrl"]) {
        throw "ClientId, ClientSecret or TokenUrl Missing. Please provide values in the environment or in ~/.sailpoint/config.yaml"
    } else {
        Write-Debug $Script:Configuration["TokenUrl"]
        Write-Debug $effectiveClientId
        Write-Debug $effectiveClientSecret

            $multipartContent = [System.Net.Http.MultipartFormDataContent]::new()

            #set grant type formdata value
            $stringHeader = [System.Net.Http.Headers.ContentDispositionHeaderValue]::new("form-data")
            $stringHeader.Name = "grant_type"
            $stringContent = [System.Net.Http.StringContent]::new([string]"client_credentials")
            $stringContent.Headers.ContentDisposition = $stringHeader
            $multipartContent.Add($stringContent)

            #set client id formdata value
            $stringHeader = [System.Net.Http.Headers.ContentDispositionHeaderValue]::new("form-data")
            $stringHeader.Name = "client_id"
            $stringContent = [System.Net.Http.StringContent]::new([string]$effectiveClientId)
            $stringContent.Headers.ContentDisposition = $stringHeader
            $multipartContent.Add($stringContent)
            #set client secret formdata value
            $stringHeader = [System.Net.Http.Headers.ContentDispositionHeaderValue]::new("form-data")
            $stringHeader.Name = "client_secret"
            $stringContent = [System.Net.Http.StringContent]::new([string]$effectiveClientSecret)
            $stringContent.Headers.ContentDisposition = $stringHeader
            $multipartContent.Add($stringContent)
        
            # Build the request and load it with the query string.
            $UriBuilder = [System.UriBuilder]($Script:Configuration["TokenUrl"])
          
            Write-Debug $UriBuilder.Uri

            
        
            try {
                if($null -eq $Script:Configuration["Proxy"]) {
                    $Response = Invoke-WebRequest -Uri $UriBuilder.Uri `
                                                -Method "POST" `
                                                -Body $multipartContent `
                                                -ErrorAction Stop `
                                                -UseBasicParsing
                } else {
                    Write-Debug $Script:Configuration["Proxy"]
                    Write-Debug $Script:Configuration["Proxy"].GetProxy($UriBuilder.Uri)
                    $Response = Invoke-WebRequest -Uri $UriBuilder.Uri `
                                                -Method "POST" `
                                                -Body $multipartContent `
                                                -ErrorAction Stop `
                                                -UseBasicParsing `
                                                -Proxy $Script:Configuration["Proxy"].GetProxy($UriBuilder.Uri) `
                                                -ProxyUseDefaultCredentials
                }             

                if ($Response.statuscode -eq '200'){
                    $Data = ConvertFrom-Json $Response.Content
                    $Token = $Data.access_token
                    $TokenExpiration = (Get-Date).AddSeconds($Data.expires_in)
                    Set-DefaultConfiguration -Token $Token -TokenExpiration $TokenExpiration -Proxy $Script:Configuration["Proxy"]
                    return $Token
                } 

            } catch {
                Write-Debug ("Exception occurred when calling Invoke-WebRequest: {0}" -f ($_.ErrorDetails | ConvertFrom-Json))
                Write-Debug ("Response headers: {0}" -f ($_.Exception.Response.Headers | ConvertTo-Json))
                return $null
            }
    }
}

function Get-EnvConfig {
    $Configuration = $Script:Configuration

    if ($null -ne $ENV:SAIL_BASE_URL) {
        $Configuration["BaseUrl"] = $ENV:SAIL_BASE_URL 
    }

    if ($null -ne $ENV:SAIL_CLIENT_ID) {
        $Configuration["ClientId"] = $ENV:SAIL_CLIENT_ID
    }

    if ($null -ne $ENV:SAIL_CLIENT_SECRET) {
        $Configuration["ClientSecret"] = $ENV:SAIL_CLIENT_SECRET
    }
    
    return $Configuration
}

function Get-LocalConfig {
    $Configuration = $Script:Configuration

    if (!(Test-Path -Path "config.json" -PathType Leaf)) { return $null }

    $LocalConfiguration = Get-Content -Path "config.json" | ConvertFrom-JSON
    
    $Configuration["ClientId"] = $LocalConfiguration.ClientId
    $Configuration["ClientSecret"] = $LocalConfiguration.ClientSecret
    $Configuration["BaseUrl"] = $LocalConfiguration.BaseUrl

    return $Configuration
}

function Get-Config {
    $Script:Configuration["ClientId"] = $null
    $Script:Configuration["ClientSecret"] = $null
    $Script:Configuration["BaseUrl"] = $null


    $EnvConfiguration = Get-EnvConfig
    if ($EnvConfiguration.clientId) {
        return $EnvConfiguration
    }

    $LocalConfig = Get-LocalConfig
    if ($LocalConfig.clientId) {
        return $LocalConfig
    }

    return $Configuration
}

<#
.SYNOPSIS

Set Client ID and Client Secret overrides for all API endpoints

.DESCRIPTION

This function sets client ID and secret overrides that will be used for all API calls instead of the default configured values.
These overrides take precedence over environment variables and config file settings.
To clear the overrides, call this function with empty strings or use Clear-ClientCredentialOverride.

.PARAMETER ClientId
The Client ID to use for authentication

.PARAMETER ClientSecret
The Client Secret to use for authentication

.EXAMPLE
Set-ClientCredentialOverride -ClientId "myClientId" -ClientSecret "myClientSecret"

.EXAMPLE
# Clear overrides
Set-ClientCredentialOverride -ClientId "" -ClientSecret ""

#>
function Set-ClientCredentialOverride {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$ClientId,
        [Parameter(Mandatory = $true)]
        [string]$ClientSecret
    )

    Process {
        if([string]::IsNullOrEmpty($ClientId) -or [string]::IsNullOrEmpty($ClientSecret)) {
            $Script:Configuration["ClientIdOverride"] = $null
            $Script:Configuration["ClientSecretOverride"] = $null
            Write-Verbose "Client credential overrides cleared"
        } else {
            $Script:Configuration["ClientIdOverride"] = $ClientId
            $Script:Configuration["ClientSecretOverride"] = $ClientSecret
            Write-Verbose "Client credential overrides set"
        }
    }
}

<#
.SYNOPSIS

Clear Client ID and Client Secret overrides

.DESCRIPTION

This function clears any client ID and secret overrides that were set using Set-ClientCredentialOverride.
After calling this function, the SDK will revert to using the default configured credentials.

.EXAMPLE
Clear-ClientCredentialOverride

#>
function Clear-ClientCredentialOverride {
    [CmdletBinding()]
    Param()

    Process {
        $Script:Configuration["ClientIdOverride"] = $null
        $Script:Configuration["ClientSecretOverride"] = $null
        Write-Verbose "Client credential overrides cleared"
    }
}

<#
.SYNOPSIS

Get the current Client ID and Client Secret override status

.DESCRIPTION

This function returns whether client credential overrides are currently set and which client ID is being used.

.EXAMPLE
Get-ClientCredentialOverride

.OUTPUTS
PSCustomObject with IsOverrideSet and ClientId properties

#>
function Get-ClientCredentialOverride {
    [CmdletBinding()]
    Param()

    Process {
        $isOverrideSet = -not [string]::IsNullOrEmpty($Script:Configuration["ClientIdOverride"])
        $clientId = if ($isOverrideSet) {
            $Script:Configuration["ClientIdOverride"]
        } else {
            $null
        }

        return [PSCustomObject]@{
            IsOverrideSet = $isOverrideSet
            ClientId = $clientId
        }
    }
}
