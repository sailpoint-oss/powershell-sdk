{"version":3,"file":"jsonrepair.js","sources":["../esm/utils/JSONRepairError.js","../esm/utils/stringUtils.js","../esm/regular/jsonrepair.js"],"sourcesContent":["export class JSONRepairError extends Error {\n  constructor(message, position) {\n    super(\"\".concat(message, \" at position \").concat(position));\n    this.position = position;\n  }\n}\n//# sourceMappingURL=JSONRepairError.js.map","const codeSpace = 0x20; // \" \"\nconst codeNewline = 0xa; // \"\\n\"\nconst codeTab = 0x9; // \"\\t\"\nconst codeReturn = 0xd; // \"\\r\"\nconst codeNonBreakingSpace = 0xa0;\nconst codeEnQuad = 0x2000;\nconst codeHairSpace = 0x200a;\nconst codeNarrowNoBreakSpace = 0x202f;\nconst codeMediumMathematicalSpace = 0x205f;\nconst codeIdeographicSpace = 0x3000;\nexport function isHex(char) {\n  return /^[0-9A-Fa-f]$/.test(char);\n}\nexport function isDigit(char) {\n  return char >= '0' && char <= '9';\n}\nexport function isValidStringCharacter(char) {\n  // note that the valid range is between \\u{0020} and \\u{10ffff},\n  // but in JavaScript it is not possible to create a code point larger than\n  // \\u{10ffff}, so there is no need to test for that here.\n  return char >= '\\u0020';\n}\nexport function isDelimiter(char) {\n  return ',:[]/{}()\\n+'.includes(char);\n}\nexport function isFunctionNameCharStart(char) {\n  return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char === '_' || char === '$';\n}\nexport function isFunctionNameChar(char) {\n  return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' || char === '_' || char === '$' || char >= '0' && char <= '9';\n}\n\n// matches \"https://\" and other schemas\nexport const regexUrlStart = /^(http|https|ftp|mailto|file|data|irc):\\/\\/$/;\n\n// matches all valid URL characters EXCEPT \"[\", \"]\", and \",\", since that are important JSON delimiters\nexport const regexUrlChar = /^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/;\nexport function isUnquotedStringDelimiter(char) {\n  return ',[]/{}\\n+'.includes(char);\n}\nexport function isStartOfValue(char) {\n  return isQuote(char) || regexStartOfValue.test(char);\n}\n\n// alpha, number, minus, or opening bracket or brace\nconst regexStartOfValue = /^[[{\\w-]$/;\nexport function isControlCharacter(char) {\n  return char === '\\n' || char === '\\r' || char === '\\t' || char === '\\b' || char === '\\f';\n}\n/**\n * Check if the given character is a whitespace character like space, tab, or\n * newline\n */\nexport function isWhitespace(text, index) {\n  const code = text.charCodeAt(index);\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\n\n/**\n * Check if the given character is a whitespace character like space or tab,\n * but NOT a newline\n */\nexport function isWhitespaceExceptNewline(text, index) {\n  const code = text.charCodeAt(index);\n  return code === codeSpace || code === codeTab || code === codeReturn;\n}\n\n/**\n * Check if the given character is a special whitespace character, some\n * unicode variant\n */\nexport function isSpecialWhitespace(text, index) {\n  const code = text.charCodeAt(index);\n  return code === codeNonBreakingSpace || code >= codeEnQuad && code <= codeHairSpace || code === codeNarrowNoBreakSpace || code === codeMediumMathematicalSpace || code === codeIdeographicSpace;\n}\n\n/**\n * Test whether the given character is a quote or double quote character.\n * Also tests for special variants of quotes.\n */\nexport function isQuote(char) {\n  // the first check double quotes, since that occurs most often\n  return isDoubleQuoteLike(char) || isSingleQuoteLike(char);\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Also tests for special variants of double quotes.\n */\nexport function isDoubleQuoteLike(char) {\n  return char === '\"' || char === '\\u201c' || char === '\\u201d';\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Does NOT test for special variants of double quotes.\n */\nexport function isDoubleQuote(char) {\n  return char === '\"';\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Also tests for special variants of single quotes.\n */\nexport function isSingleQuoteLike(char) {\n  return char === \"'\" || char === '\\u2018' || char === '\\u2019' || char === '\\u0060' || char === '\\u00b4';\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Does NOT test for special variants of single quotes.\n */\nexport function isSingleQuote(char) {\n  return char === \"'\";\n}\n\n/**\n * Strip last occurrence of textToStrip from text\n */\nexport function stripLastOccurrence(text, textToStrip) {\n  let stripRemainingText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const index = text.lastIndexOf(textToStrip);\n  return index !== -1 ? text.substring(0, index) + (stripRemainingText ? '' : text.substring(index + 1)) : text;\n}\nexport function insertBeforeLastWhitespace(text, textToInsert) {\n  let index = text.length;\n  if (!isWhitespace(text, index - 1)) {\n    // no trailing whitespaces\n    return text + textToInsert;\n  }\n  while (isWhitespace(text, index - 1)) {\n    index--;\n  }\n  return text.substring(0, index) + textToInsert + text.substring(index);\n}\nexport function removeAtIndex(text, start, count) {\n  return text.substring(0, start) + text.substring(start + count);\n}\n\n/**\n * Test whether a string ends with a newline or comma character and optional whitespace\n */\nexport function endsWithCommaOrNewline(text) {\n  return /[,\\n][ \\t\\r]*$/.test(text);\n}\n//# sourceMappingURL=stringUtils.js.map","import { JSONRepairError } from '../utils/JSONRepairError.js';\nimport { endsWithCommaOrNewline, insertBeforeLastWhitespace, isControlCharacter, isDelimiter, isDigit, isDoubleQuote, isDoubleQuoteLike, isFunctionNameChar, isFunctionNameCharStart, isHex, isQuote, isSingleQuote, isSingleQuoteLike, isSpecialWhitespace, isStartOfValue, isUnquotedStringDelimiter, isValidStringCharacter, isWhitespace, isWhitespaceExceptNewline, regexUrlChar, regexUrlStart, removeAtIndex, stripLastOccurrence } from '../utils/stringUtils.js';\nconst controlCharacters = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n};\n\n// map with all escape characters\nconst escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     try {\n *       const json = \"{name: 'John'}\"\n *       const repaired = jsonrepair(json)\n *       console.log(repaired)\n *       // '{\"name\": \"John\"}'\n *     } catch (err) {\n *       console.error(err)\n *     }\n *\n */\nexport function jsonrepair(text) {\n  let i = 0; // current index in text\n  let output = ''; // generated output\n\n  parseMarkdownCodeBlock();\n  const processed = parseValue();\n  if (!processed) {\n    throwUnexpectedEnd();\n  }\n  parseMarkdownCodeBlock();\n  const processedComma = parseCharacter(',');\n  if (processedComma) {\n    parseWhitespaceAndSkipComments();\n  }\n  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n    if (!processedComma) {\n      // repair missing comma\n      output = insertBeforeLastWhitespace(output, ',');\n    }\n    parseNewlineDelimitedJSON();\n  } else if (processedComma) {\n    // repair: remove trailing comma\n    output = stripLastOccurrence(output, ',');\n  }\n\n  // repair redundant end quotes\n  while (text[i] === '}' || text[i] === ']') {\n    i++;\n    parseWhitespaceAndSkipComments();\n  }\n  if (i >= text.length) {\n    // reached the end of the document properly\n    return output;\n  }\n  throwUnexpectedCharacter();\n  function parseValue() {\n    parseWhitespaceAndSkipComments();\n    const processed = parseObject() || parseArray() || parseString() || parseNumber() || parseKeywords() || parseUnquotedString(false) || parseRegex();\n    parseWhitespaceAndSkipComments();\n    return processed;\n  }\n  function parseWhitespaceAndSkipComments() {\n    let skipNewline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const start = i;\n    let changed = parseWhitespace(skipNewline);\n    do {\n      changed = parseComment();\n      if (changed) {\n        changed = parseWhitespace(skipNewline);\n      }\n    } while (changed);\n    return i > start;\n  }\n  function parseWhitespace(skipNewline) {\n    const _isWhiteSpace = skipNewline ? isWhitespace : isWhitespaceExceptNewline;\n    let whitespace = '';\n    while (true) {\n      if (_isWhiteSpace(text, i)) {\n        whitespace += text[i];\n        i++;\n      } else if (isSpecialWhitespace(text, i)) {\n        // repair special whitespace\n        whitespace += ' ';\n        i++;\n      } else {\n        break;\n      }\n    }\n    if (whitespace.length > 0) {\n      output += whitespace;\n      return true;\n    }\n    return false;\n  }\n  function parseComment() {\n    // find a block comment '/* ... */'\n    if (text[i] === '/' && text[i + 1] === '*') {\n      // repair block comment by skipping it\n      while (i < text.length && !atEndOfBlockComment(text, i)) {\n        i++;\n      }\n      i += 2;\n      return true;\n    }\n\n    // find a line comment '// ...'\n    if (text[i] === '/' && text[i + 1] === '/') {\n      // repair line comment by skipping it\n      while (i < text.length && text[i] !== '\\n') {\n        i++;\n      }\n      return true;\n    }\n    return false;\n  }\n  function parseMarkdownCodeBlock() {\n    // find and skip over a Markdown fenced code block:\n    //     ``` ... ```\n    // or\n    //     ```json ... ```\n    if (text.slice(i, i + 3) === '```') {\n      i += 3;\n      if (isFunctionNameCharStart(text[i])) {\n        // strip the optional language specifier like \"json\"\n        while (i < text.length && isFunctionNameChar(text[i])) {\n          i++;\n        }\n      }\n      parseWhitespaceAndSkipComments();\n      return true;\n    }\n    return false;\n  }\n  function parseCharacter(char) {\n    if (text[i] === char) {\n      output += text[i];\n      i++;\n      return true;\n    }\n    return false;\n  }\n  function skipCharacter(char) {\n    if (text[i] === char) {\n      i++;\n      return true;\n    }\n    return false;\n  }\n  function skipEscapeCharacter() {\n    return skipCharacter('\\\\');\n  }\n\n  /**\n   * Skip ellipsis like \"[1,2,3,...]\" or \"[1,2,3,...,9]\" or \"[...,7,8,9]\"\n   * or a similar construct in objects.\n   */\n  function skipEllipsis() {\n    parseWhitespaceAndSkipComments();\n    if (text[i] === '.' && text[i + 1] === '.' && text[i + 2] === '.') {\n      // repair: remove the ellipsis (three dots) and optionally a comma\n      i += 3;\n      parseWhitespaceAndSkipComments();\n      skipCharacter(',');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse an object like '{\"key\": \"value\"}'\n   */\n  function parseObject() {\n    if (text[i] === '{') {\n      output += '{';\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: skip leading comma like in {, message: \"hi\"}\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments();\n      }\n      let initial = true;\n      while (i < text.length && text[i] !== '}') {\n        let processedComma;\n        if (!initial) {\n          processedComma = parseCharacter(',');\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',');\n          }\n          parseWhitespaceAndSkipComments();\n        } else {\n          processedComma = true;\n          initial = false;\n        }\n        skipEllipsis();\n        const processedKey = parseString() || parseUnquotedString(true);\n        if (!processedKey) {\n          if (text[i] === '}' || text[i] === '{' || text[i] === ']' || text[i] === '[' || text[i] === undefined) {\n            // repair trailing comma\n            output = stripLastOccurrence(output, ',');\n          } else {\n            throwObjectKeyExpected();\n          }\n          break;\n        }\n        parseWhitespaceAndSkipComments();\n        const processedColon = parseCharacter(':');\n        const truncatedText = i >= text.length;\n        if (!processedColon) {\n          if (isStartOfValue(text[i]) || truncatedText) {\n            // repair missing colon\n            output = insertBeforeLastWhitespace(output, ':');\n          } else {\n            throwColonExpected();\n          }\n        }\n        const processedValue = parseValue();\n        if (!processedValue) {\n          if (processedColon || truncatedText) {\n            // repair missing object value\n            output += 'null';\n          } else {\n            throwColonExpected();\n          }\n        }\n      }\n      if (text[i] === '}') {\n        output += '}';\n        i++;\n      } else {\n        // repair missing end bracket\n        output = insertBeforeLastWhitespace(output, '}');\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse an array like '[\"item1\", \"item2\", ...]'\n   */\n  function parseArray() {\n    if (text[i] === '[') {\n      output += '[';\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: skip leading comma like in [,1,2,3]\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments();\n      }\n      let initial = true;\n      while (i < text.length && text[i] !== ']') {\n        if (!initial) {\n          const processedComma = parseCharacter(',');\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',');\n          }\n        } else {\n          initial = false;\n        }\n        skipEllipsis();\n        const processedValue = parseValue();\n        if (!processedValue) {\n          // repair trailing comma\n          output = stripLastOccurrence(output, ',');\n          break;\n        }\n      }\n      if (text[i] === ']') {\n        output += ']';\n        i++;\n      } else {\n        // repair missing closing array bracket\n        output = insertBeforeLastWhitespace(output, ']');\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse and repair Newline Delimited JSON (NDJSON):\n   * multiple JSON objects separated by a newline character\n   */\n  function parseNewlineDelimitedJSON() {\n    // repair NDJSON\n    let initial = true;\n    let processedValue = true;\n    while (processedValue) {\n      if (!initial) {\n        // parse optional comma, insert when missing\n        const processedComma = parseCharacter(',');\n        if (!processedComma) {\n          // repair: add missing comma\n          output = insertBeforeLastWhitespace(output, ',');\n        }\n      } else {\n        initial = false;\n      }\n      processedValue = parseValue();\n    }\n    if (!processedValue) {\n      // repair: remove trailing comma\n      output = stripLastOccurrence(output, ',');\n    }\n\n    // repair: wrap the output inside array brackets\n    output = \"[\\n\".concat(output, \"\\n]\");\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   *\n   * The function can run in two stages:\n   * - First, it assumes the string has a valid end quote\n   * - If it turns out that the string does not have a valid end quote followed\n   *   by a delimiter (which should be the case), the function runs again in a\n   *   more conservative way, stopping the string at the first next delimiter\n   *   and fixing the string by inserting a quote there, or stopping at a\n   *   stop index detected in the first iteration.\n   */\n  function parseString() {\n    let stopAtDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let stopAtIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let skipEscapeChars = text[i] === '\\\\';\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++;\n      skipEscapeChars = true;\n    }\n    if (isQuote(text[i])) {\n      // double quotes are correct JSON,\n      // single quotes come from JavaScript for example, we assume it will have a correct single end quote too\n      // otherwise, we will match any double-quote-like start with a double-quote-like end,\n      // or any single-quote-like start with a single-quote-like end\n      const isEndQuote = isDoubleQuote(text[i]) ? isDoubleQuote : isSingleQuote(text[i]) ? isSingleQuote : isSingleQuoteLike(text[i]) ? isSingleQuoteLike : isDoubleQuoteLike;\n      const iBefore = i;\n      const oBefore = output.length;\n      let str = '\"';\n      i++;\n      while (true) {\n        if (i >= text.length) {\n          // end of text, we are missing an end quote\n\n          const iPrev = prevNonWhitespaceIndex(i - 1);\n          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {\n            // if the text ends with a delimiter, like [\"hello],\n            // so the missing end quote should be inserted before this delimiter\n            // retry parsing the string, stopping at the first next delimiter\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(true);\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          return true;\n          // biome-ignore lint/style/noUselessElse: <explanation>\n        } else if (i === stopAtIndex) {\n          // use the stop index detected in the first iteration, and repair end quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          return true;\n          // biome-ignore lint/style/noUselessElse: <explanation>\n        } else if (isEndQuote(text[i])) {\n          // end quote\n          // let us check what is before and after the quote to verify whether this is a legit end quote\n          const iQuote = i;\n          const oQuote = str.length;\n          str += '\"';\n          i++;\n          output += str;\n          parseWhitespaceAndSkipComments(false);\n          if (stopAtDelimiter || i >= text.length || isDelimiter(text[i]) || isQuote(text[i]) || isDigit(text[i])) {\n            // The quote is followed by the end of the text, a delimiter,\n            // or a next value. So the quote is indeed the end of the string.\n            parseConcatenatedString();\n            return true;\n          }\n          const iPrevChar = prevNonWhitespaceIndex(iQuote - 1);\n          const prevChar = text.charAt(iPrevChar);\n          if (prevChar === ',') {\n            // A comma followed by a quote, like '{\"a\":\"b,c,\"d\":\"e\"}'.\n            // We assume that the quote is a start quote, and that the end quote\n            // should have been located right before the comma but is missing.\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(false, iPrevChar);\n          }\n          if (isDelimiter(prevChar)) {\n            // This is not the right end quote: it is preceded by a delimiter,\n            // and NOT followed by a delimiter. So, there is an end quote missing\n            // parse the string again and then stop at the first next delimiter\n            i = iBefore;\n            output = output.substring(0, oBefore);\n            return parseString(true);\n          }\n\n          // revert to right after the quote but before any whitespace, and continue parsing the string\n          output = output.substring(0, oBefore);\n          i = iQuote + 1;\n\n          // repair unescaped quote\n          str = \"\".concat(str.substring(0, oQuote), \"\\\\\").concat(str.substring(oQuote));\n        } else if (stopAtDelimiter && isUnquotedStringDelimiter(text[i])) {\n          // we're in the mode to stop the string at the first delimiter\n          // because there is an end quote missing\n\n          // test start of an url like \"https://...\" (this would be parsed as a comment)\n          if (text[i - 1] === ':' && regexUrlStart.test(text.substring(iBefore + 1, i + 2))) {\n            while (i < text.length && regexUrlChar.test(text[i])) {\n              str += text[i];\n              i++;\n            }\n          }\n\n          // repair missing quote\n          str = insertBeforeLastWhitespace(str, '\"');\n          output += str;\n          parseConcatenatedString();\n          return true;\n        } else if (text[i] === '\\\\') {\n          // handle escaped content like \\n or \\u2605\n          const char = text.charAt(i + 1);\n          const escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            str += text.slice(i, i + 2);\n            i += 2;\n          } else if (char === 'u') {\n            let j = 2;\n            while (j < 6 && isHex(text[i + j])) {\n              j++;\n            }\n            if (j === 6) {\n              str += text.slice(i, i + 6);\n              i += 6;\n            } else if (i + j >= text.length) {\n              // repair invalid or truncated unicode char at the end of the text\n              // by removing the unicode char and ending the string here\n              i = text.length;\n            } else {\n              throwInvalidUnicodeCharacter();\n            }\n          } else {\n            // repair invalid escape character: remove it\n            str += char;\n            i += 2;\n          }\n        } else {\n          // handle regular characters\n          const char = text.charAt(i);\n          if (char === '\"' && text[i - 1] !== '\\\\') {\n            // repair unescaped double quote\n            str += \"\\\\\".concat(char);\n            i++;\n          } else if (isControlCharacter(char)) {\n            // unescaped control character\n            str += controlCharacters[char];\n            i++;\n          } else {\n            if (!isValidStringCharacter(char)) {\n              throwInvalidCharacter(char);\n            }\n            str += char;\n            i++;\n          }\n        }\n        if (skipEscapeChars) {\n          // repair: skipped escape character (nothing to do)\n          skipEscapeCharacter();\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString() {\n    let processed = false;\n    parseWhitespaceAndSkipComments();\n    while (text[i] === '+') {\n      processed = true;\n      i++;\n      parseWhitespaceAndSkipComments();\n\n      // repair: remove the end quote of the first string\n      output = stripLastOccurrence(output, '\"', true);\n      const start = output.length;\n      const parsedStr = parseString();\n      if (parsedStr) {\n        // repair: remove the start quote of the second string\n        output = removeAtIndex(output, start, 1);\n      } else {\n        // repair: remove the + because it is not followed by a string\n        output = insertBeforeLastWhitespace(output, '\"');\n      }\n    }\n    return processed;\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber() {\n    const start = i;\n    if (text[i] === '-') {\n      i++;\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text[i])) {\n        i = start;\n        return false;\n      }\n    }\n\n    // Note that in JSON leading zeros like \"00789\" are not allowed.\n    // We will allow all leading zeros here though and at the end of parseNumber\n    // check against trailing zeros and repair that if needed.\n    // Leading zeros can have meaning, so we should not clear them.\n    while (isDigit(text[i])) {\n      i++;\n    }\n    if (text[i] === '.') {\n      i++;\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text[i])) {\n        i = start;\n        return false;\n      }\n      while (isDigit(text[i])) {\n        i++;\n      }\n    }\n    if (text[i] === 'e' || text[i] === 'E') {\n      i++;\n      if (text[i] === '-' || text[i] === '+') {\n        i++;\n      }\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start);\n        return true;\n      }\n      if (!isDigit(text[i])) {\n        i = start;\n        return false;\n      }\n      while (isDigit(text[i])) {\n        i++;\n      }\n    }\n\n    // if we're not at the end of the number by this point, allow this to be parsed as another type\n    if (!atEndOfNumber()) {\n      i = start;\n      return false;\n    }\n    if (i > start) {\n      // repair a number with leading zeros like \"00789\"\n      const num = text.slice(start, i);\n      const hasInvalidLeadingZero = /^0\\d/.test(num);\n      output += hasInvalidLeadingZero ? \"\\\"\".concat(num, \"\\\"\") : num;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords() {\n    return parseKeyword('true', 'true') || parseKeyword('false', 'false') || parseKeyword('null', 'null') ||\n    // repair Python keywords True, False, None\n    parseKeyword('True', 'true') || parseKeyword('False', 'false') || parseKeyword('None', 'null');\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      output += value;\n      i += name.length;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Repair an unquoted string by adding quotes around it\n   * Repair a MongoDB function call like NumberLong(\"2\")\n   * Repair a JSONP function call like callback({...});\n   */\n  function parseUnquotedString(isKey) {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    // also, note that we allow strings to contain a slash / in order to support repairing regular expressions\n    const start = i;\n    if (isFunctionNameCharStart(text[i])) {\n      while (i < text.length && isFunctionNameChar(text[i])) {\n        i++;\n      }\n      let j = i;\n      while (isWhitespace(text, j)) {\n        j++;\n      }\n      if (text[j] === '(') {\n        // repair a MongoDB function call like NumberLong(\"2\")\n        // repair a JSONP function call like callback({...});\n        i = j + 1;\n        parseValue();\n        if (text[i] === ')') {\n          // repair: skip close bracket of function call\n          i++;\n          if (text[i] === ';') {\n            // repair: skip semicolon after JSONP call\n            i++;\n          }\n        }\n        return true;\n      }\n    }\n    while (i < text.length && !isUnquotedStringDelimiter(text[i]) && !isQuote(text[i]) && (!isKey || text[i] !== ':')) {\n      i++;\n    }\n\n    // test start of an url like \"https://...\" (this would be parsed as a comment)\n    if (text[i - 1] === ':' && regexUrlStart.test(text.substring(start, i + 2))) {\n      while (i < text.length && regexUrlChar.test(text[i])) {\n        i++;\n      }\n    }\n    if (i > start) {\n      // repair unquoted string\n      // also, repair undefined into null\n\n      // first, go back to prevent getting trailing whitespaces in the string\n      while (isWhitespace(text, i - 1) && i > 0) {\n        i--;\n      }\n      const symbol = text.slice(start, i);\n      output += symbol === 'undefined' ? 'null' : JSON.stringify(symbol);\n      if (text[i] === '\"') {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++;\n      }\n      return true;\n    }\n  }\n  function parseRegex() {\n    if (text[i] === '/') {\n      const start = i;\n      i++;\n      while (i < text.length && (text[i] !== '/' || text[i - 1] === '\\\\')) {\n        i++;\n      }\n      i++;\n      output += \"\\\"\".concat(text.substring(start, i), \"\\\"\");\n      return true;\n    }\n  }\n  function prevNonWhitespaceIndex(start) {\n    let prev = start;\n    while (prev > 0 && isWhitespace(text, prev)) {\n      prev--;\n    }\n    return prev;\n  }\n  function atEndOfNumber() {\n    return i >= text.length || isDelimiter(text[i]) || isWhitespace(text, i);\n  }\n  function repairNumberEndingWithNumericSymbol(start) {\n    // repair numbers cut off at the end\n    // this will only be called when we end after a '.', '-', or 'e' and does not\n    // change the number more than it needs to make it valid JSON\n    output += \"\".concat(text.slice(start, i), \"0\");\n  }\n  function throwInvalidCharacter(char) {\n    throw new JSONRepairError(\"Invalid character \".concat(JSON.stringify(char)), i);\n  }\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError(\"Unexpected character \".concat(JSON.stringify(text[i])), i);\n  }\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', text.length);\n  }\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i);\n  }\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i);\n  }\n  function throwInvalidUnicodeCharacter() {\n    const chars = text.slice(i, i + 6);\n    throw new JSONRepairError(\"Invalid unicode character \\\"\".concat(chars, \"\\\"\"), i);\n  }\n}\nfunction atEndOfBlockComment(text, i) {\n  return text[i] === '*' && text[i + 1] === '/';\n}\n//# sourceMappingURL=jsonrepair.js.map"],"names":[],"mappings":"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"}