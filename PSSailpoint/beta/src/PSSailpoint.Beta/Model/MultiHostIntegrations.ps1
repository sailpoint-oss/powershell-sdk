#
# Identity Security Cloud Beta API
# Use these APIs to interact with the Identity Security Cloud platform to achieve repeatable, automated processes with greater scalability. These APIs are in beta and are subject to change. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.
# Version: 3.1.0-beta
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

No summary available.

.DESCRIPTION

No description available.

.PARAMETER Name
Multi-Host Integration's human-readable name.
.PARAMETER Description
Multi-Host Integration's human-readable description.
.PARAMETER Owner
No description available.
.PARAMETER Cluster
No description available.
.PARAMETER Type
Specifies the type of system being managed e.g. Workday, Multi-Host - Microsoft SQL Server, etc.. If you are creating a delimited file source, you must set the `provisionasCsv` query parameter to `true`. 
.PARAMETER Connector
Connector script name.
.PARAMETER LastSourceUploadSuccessCount
Last successfully uploaded source count of given Multi-Host Integration.
.PARAMETER MaxSourcesPerAggGroup
Maximum sources that can contain in a aggregation group of Multi-Host Integration.
.PARAMETER ConnectorClass
Fully qualified name of the Java class that implements the connector interface.
.PARAMETER ConnectorAttributes
No description available.
.PARAMETER DeleteThreshold
Number from 0 to 100 that specifies when to skip the delete phase.
.PARAMETER Authoritative
When this is true, it indicates that the source is referenced by an identity profile.
.PARAMETER ManagementWorkgroup
No description available.
.PARAMETER Healthy
When this is true, it indicates that the source is healthy.
.PARAMETER Status
Status identifier that gives specific information about why a source is or isn't healthy. 
.PARAMETER Since
Timestamp that shows when a source health check was last performed.
.PARAMETER ConnectorId
Connector ID
.PARAMETER ConnectorName
Name of the connector that was chosen during source creation.
.PARAMETER ConnectionType
Type of connection (direct or file).
.PARAMETER ConnectorImplementationId
Connector implementation ID.
.PARAMETER Created
Date-time when the source was created
.PARAMETER Modified
Date-time when the source was last modified.
.PARAMETER CredentialProviderEnabled
If this is true, it enables a credential provider for the source. If credentialProvider is turned on,  then the source can use credential provider(s) to fetch credentials.
.PARAMETER Category
Source category (e.g. null, CredentialProvider).
.OUTPUTS

MultiHostIntegrations<PSCustomObject>
#>

function Initialize-BetaMultiHostIntegrations {
    [CmdletBinding()]
    Param (
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Name},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Description},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCustomObject]
        ${Owner},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCustomObject]
        ${Cluster},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Type},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Connector},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${LastSourceUploadSuccessCount},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${MaxSourcesPerAggGroup},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${ConnectorClass},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCustomObject]
        ${ConnectorAttributes},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${DeleteThreshold},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Boolean]]
        ${Authoritative} = $false,
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [PSCustomObject]
        ${ManagementWorkgroup},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Boolean]]
        ${Healthy} = $false,
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateSet("SOURCE_STATE_ERROR_ACCOUNT_FILE_IMPORT", "SOURCE_STATE_ERROR_CLUSTER", "SOURCE_STATE_ERROR_SOURCE", "SOURCE_STATE_ERROR_VA", "SOURCE_STATE_FAILURE_CLUSTER", "SOURCE_STATE_FAILURE_SOURCE", "SOURCE_STATE_HEALTHY", "SOURCE_STATE_UNCHECKED_CLUSTER", "SOURCE_STATE_UNCHECKED_CLUSTER_NO_SOURCES", "SOURCE_STATE_UNCHECKED_SOURCE", "SOURCE_STATE_UNCHECKED_SOURCE_NO_ACCOUNTS")]
        [String]
        ${Status},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[System.DateTime]]
        ${Since},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${ConnectorId},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${ConnectorName},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateSet("direct", "file")]
        [String]
        ${ConnectionType},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${ConnectorImplementationId},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[System.DateTime]]
        ${Created},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[System.DateTime]]
        ${Modified},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Boolean]]
        ${CredentialProviderEnabled} = $false,
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Category}
    )

    Process {
        'Creating PSCustomObject: PSSailpoint.Beta => BetaMultiHostIntegrations' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        if (!$Name) {
            throw "invalid value for 'Name', 'Name' cannot be null."
        }

        if (!$Description) {
            throw "invalid value for 'Description', 'Description' cannot be null."
        }

        if (!$Owner) {
            throw "invalid value for 'Owner', 'Owner' cannot be null."
        }

        if (!$Connector) {
            throw "invalid value for 'Connector', 'Connector' cannot be null."
        }

        if ($DeleteThreshold -and $DeleteThreshold -gt 100) {
          throw "invalid value for 'DeleteThreshold', must be smaller than or equal to 100."
        }

        if ($DeleteThreshold -and $DeleteThreshold -lt 0) {
          throw "invalid value for 'DeleteThreshold', must be greater than or equal to 0."
        }


        $PSO = [PSCustomObject]@{
            "name" = ${Name}
            "description" = ${Description}
            "owner" = ${Owner}
            "cluster" = ${Cluster}
            "type" = ${Type}
            "connector" = ${Connector}
            "lastSourceUploadSuccessCount" = ${LastSourceUploadSuccessCount}
            "maxSourcesPerAggGroup" = ${MaxSourcesPerAggGroup}
            "connectorClass" = ${ConnectorClass}
            "connectorAttributes" = ${ConnectorAttributes}
            "deleteThreshold" = ${DeleteThreshold}
            "authoritative" = ${Authoritative}
            "managementWorkgroup" = ${ManagementWorkgroup}
            "healthy" = ${Healthy}
            "status" = ${Status}
            "since" = ${Since}
            "connectorId" = ${ConnectorId}
            "connectorName" = ${ConnectorName}
            "connectionType" = ${ConnectionType}
            "connectorImplementationId" = ${ConnectorImplementationId}
            "created" = ${Created}
            "modified" = ${Modified}
            "credentialProviderEnabled" = ${CredentialProviderEnabled}
            "category" = ${Category}
        }

        return $PSO
    }
}

<#
.SYNOPSIS

Convert from JSON to MultiHostIntegrations<PSCustomObject>

.DESCRIPTION

Convert from JSON to MultiHostIntegrations<PSCustomObject>

.PARAMETER Json

Json object

.OUTPUTS

MultiHostIntegrations<PSCustomObject>
#>
function ConvertFrom-BetaJsonToMultiHostIntegrations {
    Param(
        [AllowEmptyString()]
        [string]$Json
    )

    Process {
        'Converting JSON to PSCustomObject: PSSailpoint.Beta => BetaMultiHostIntegrations' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $JsonParameters = ConvertFrom-Json -InputObject $Json

        # check if Json contains properties not defined in BetaMultiHostIntegrations
        $AllProperties = ("id", "name", "description", "owner", "cluster", "type", "connector", "lastSourceUploadSuccessCount", "maxSourcesPerAggGroup", "connectorClass", "connectorAttributes", "deleteThreshold", "authoritative", "managementWorkgroup", "healthy", "status", "since", "connectorId", "connectorName", "connectionType", "connectorImplementationId", "created", "modified", "credentialProviderEnabled", "category")
        foreach ($name in $JsonParameters.PsObject.Properties.Name) {
            if (!($AllProperties.Contains($name))) {
                throw "Error! JSON key '$name' not found in the properties: $($AllProperties)"
            }
        }

        If ([string]::IsNullOrEmpty($Json) -or $Json -eq "{}") { # empty json
            throw "Error! Empty JSON cannot be serialized due to the required property 'id' missing."
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "id"))) {
            throw "Error! JSON cannot be serialized due to the required property 'id' missing."
        } else {
            $Id = $JsonParameters.PSobject.Properties["id"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "name"))) {
            throw "Error! JSON cannot be serialized due to the required property 'name' missing."
        } else {
            $Name = $JsonParameters.PSobject.Properties["name"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "description"))) {
            throw "Error! JSON cannot be serialized due to the required property 'description' missing."
        } else {
            $Description = $JsonParameters.PSobject.Properties["description"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "owner"))) {
            throw "Error! JSON cannot be serialized due to the required property 'owner' missing."
        } else {
            $Owner = $JsonParameters.PSobject.Properties["owner"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "connector"))) {
            throw "Error! JSON cannot be serialized due to the required property 'connector' missing."
        } else {
            $Connector = $JsonParameters.PSobject.Properties["connector"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "cluster"))) { #optional property not found
            $Cluster = $null
        } else {
            $Cluster = $JsonParameters.PSobject.Properties["cluster"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "type"))) { #optional property not found
            $Type = $null
        } else {
            $Type = $JsonParameters.PSobject.Properties["type"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "lastSourceUploadSuccessCount"))) { #optional property not found
            $LastSourceUploadSuccessCount = $null
        } else {
            $LastSourceUploadSuccessCount = $JsonParameters.PSobject.Properties["lastSourceUploadSuccessCount"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "maxSourcesPerAggGroup"))) { #optional property not found
            $MaxSourcesPerAggGroup = $null
        } else {
            $MaxSourcesPerAggGroup = $JsonParameters.PSobject.Properties["maxSourcesPerAggGroup"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "connectorClass"))) { #optional property not found
            $ConnectorClass = $null
        } else {
            $ConnectorClass = $JsonParameters.PSobject.Properties["connectorClass"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "connectorAttributes"))) { #optional property not found
            $ConnectorAttributes = $null
        } else {
            $ConnectorAttributes = $JsonParameters.PSobject.Properties["connectorAttributes"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "deleteThreshold"))) { #optional property not found
            $DeleteThreshold = $null
        } else {
            $DeleteThreshold = $JsonParameters.PSobject.Properties["deleteThreshold"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "authoritative"))) { #optional property not found
            $Authoritative = $null
        } else {
            $Authoritative = $JsonParameters.PSobject.Properties["authoritative"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "managementWorkgroup"))) { #optional property not found
            $ManagementWorkgroup = $null
        } else {
            $ManagementWorkgroup = $JsonParameters.PSobject.Properties["managementWorkgroup"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "healthy"))) { #optional property not found
            $Healthy = $null
        } else {
            $Healthy = $JsonParameters.PSobject.Properties["healthy"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "status"))) { #optional property not found
            $Status = $null
        } else {
            $Status = $JsonParameters.PSobject.Properties["status"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "since"))) { #optional property not found
            $Since = $null
        } else {
            $Since = $JsonParameters.PSobject.Properties["since"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "connectorId"))) { #optional property not found
            $ConnectorId = $null
        } else {
            $ConnectorId = $JsonParameters.PSobject.Properties["connectorId"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "connectorName"))) { #optional property not found
            $ConnectorName = $null
        } else {
            $ConnectorName = $JsonParameters.PSobject.Properties["connectorName"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "connectionType"))) { #optional property not found
            $ConnectionType = $null
        } else {
            $ConnectionType = $JsonParameters.PSobject.Properties["connectionType"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "connectorImplementationId"))) { #optional property not found
            $ConnectorImplementationId = $null
        } else {
            $ConnectorImplementationId = $JsonParameters.PSobject.Properties["connectorImplementationId"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "created"))) { #optional property not found
            $Created = $null
        } else {
            $Created = $JsonParameters.PSobject.Properties["created"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "modified"))) { #optional property not found
            $Modified = $null
        } else {
            $Modified = $JsonParameters.PSobject.Properties["modified"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "credentialProviderEnabled"))) { #optional property not found
            $CredentialProviderEnabled = $null
        } else {
            $CredentialProviderEnabled = $JsonParameters.PSobject.Properties["credentialProviderEnabled"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "category"))) { #optional property not found
            $Category = $null
        } else {
            $Category = $JsonParameters.PSobject.Properties["category"].value
        }

        $PSO = [PSCustomObject]@{
            "id" = ${Id}
            "name" = ${Name}
            "description" = ${Description}
            "owner" = ${Owner}
            "cluster" = ${Cluster}
            "type" = ${Type}
            "connector" = ${Connector}
            "lastSourceUploadSuccessCount" = ${LastSourceUploadSuccessCount}
            "maxSourcesPerAggGroup" = ${MaxSourcesPerAggGroup}
            "connectorClass" = ${ConnectorClass}
            "connectorAttributes" = ${ConnectorAttributes}
            "deleteThreshold" = ${DeleteThreshold}
            "authoritative" = ${Authoritative}
            "managementWorkgroup" = ${ManagementWorkgroup}
            "healthy" = ${Healthy}
            "status" = ${Status}
            "since" = ${Since}
            "connectorId" = ${ConnectorId}
            "connectorName" = ${ConnectorName}
            "connectionType" = ${ConnectionType}
            "connectorImplementationId" = ${ConnectorImplementationId}
            "created" = ${Created}
            "modified" = ${Modified}
            "credentialProviderEnabled" = ${CredentialProviderEnabled}
            "category" = ${Category}
        }

        return $PSO
    }

}

